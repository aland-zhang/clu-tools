#!/bin/bash

#  Copyright 2008 Simon HÃ¼rlimann <simon.huerlimann@cyt.ch>
#  Copyright 2008 ZytoLabor <info@zyto-labor.com>
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.

set -e

# Commandline Parsing
# ===================
function usage() {
	echo "Usage: $(basename $0) create <SECONDARY> <RESOURCE> [<DEVICE=drbd0> <PORT=7788> <SIZE=1G> <LVM_VG=hostname>]"
	echo "                      create_from_physical <SECONDARY> <RESOURCE> [<DEVICE=drbd0> <PORT=7788> <LV_VG=hostname>]"
	echo "                      destroy <RESOURCE>"
	echo
	echo "Environment variables"
	echo "	SKIP_RESIZE: if '1' don't resize LVM partition to make space for DRBD meta-data"
	echo "	SKIP_CONF: if '1' don't update DRBD config-file"
	echo

	exit 0
}
if [ $# -lt 1 ] ; then
	usage
fi


 
# Helper functions
# ================
function get_ip() {
local name=$1

	host $name | cut -d ' ' -f 4
}

function drbd_resource_config() {
local primary=$1
local secondary=$2
local resource=$3
local disk=$4
local device=${5:-$(get_next_device)}
local port=${6:-$(get_next_port)}

        # Add DRBD ressource config snipple
        cat <<EOF
##### Autogenerated section '$resource' by clu-tools #####
resource "$resource" {
	protocol C;
	net {
		allow-two-primaries;
	}

        on $primary {
        	address $(get_ip $primary):$port;
                disk $disk;
                device /dev/$device;
                meta-disk "internal";
        }
        on $secondary {
        	address $(get_ip $secondary):$port;
	        disk $disk;
                device /dev/$device;
                meta-disk "internal";
        }
}
##### End section '$resource' #####
EOF
}

# calculate size for internal metadata
#  $1: resource path
# ret: size in bytes

function calculate_meta() {
local resource=$1

	local device=$(clu-$(get_device_type $resource) get_device $resource)
	local size=$(blockdev --getsize64 $device)
	local size_mb=$(( $size / 512 * 8 / ( 2 ** 18 ) + 72))

	echo $(( $size_mb * ( 2 ** 20 ) ))
}

function cut_section() {
local resource=$1

	cat /etc/drbd.conf | awk -f /usr/local/bin/clu-tools/cut_section.awk -v resource=$resource >/etc/drbd.conf
}

function extract_section() {
local resource=$1

	cat /etc/drbd.conf | awk -f /usr/local/bin/clu-tools/extract_section.awk -v resource=$resource
}


function extract_disk() {
local resource=$1

        extract_section $resource | sed -n 's#[^#]*[[:space:]]disk[[:space:]]*\(/dev/[^;]*\);.*#\1#p'
}
        
function get_next_device() {
        id="$(( $(drbdadm sh-dev all | sed 's#/dev/drbd##' | sort --unique --numeric-sort | tail -1) + 1 ))"
        echo "drbd$id"
}

function get_next_port() {
	echo $(( $(drbdadm dump-xml | grep '<address' | sed 's/.*<address port="\(.*\)">.*/\1/' | sort --unique --numeric-sort | tail -1) + 1 ))
}

function get_device() {
local resource=$1

	drbdadm sh-dev $resource
}

function get_disk() {
local resource=$1

	drbdadm sh-md-dev $resource
}

function get_peer() {
local resource=$1

	# Argh... Ugly as hell
	drbdsetup $(get_device $resource) show | grep -A 1 _remote_host | tail -1 |cut -d $'\t' -f 5 | cut -d ':' -f 1
}

function run_on_peer() {
local $resource=$1
local $command="$@"

	ssh $(get_peer $resource) $command
}

# Commands
# ========


function get_size() {
local resource=$1

        blockdev --getsize64 $(get_device $resource)
}

function grow_to() {
local resource=$1
local new_size=$2

	# Local disk
	clu-disk grow_to $(get_disk $resource) $new_size

	# Remote disk
	run_on_peer $resource clu-disk grow_to $(get_disk $resource) $new_size
	
	# Grow DRBD
	drbdadm resize $resource
}

function grow_by() {
local resource=$1
local size_increment=$2

	local old_size=$(get_size $resource)
	local new_size=$(( $old_size + $size_increment ))
	
	grow_to $resource $new_size
}



function get_device_type() {
local device=$1

	if lvdisplay | grep --quiet "$device" ; then
		echo "lvm"
	elif echo "$(clu-loop get_device $device)" | grep --quiet '/dev/loop' ; then
		echo "loop"
	else
		echo "[ERROR] Unknown disk type"
		exit 1
	fi
}

function grow_for_meta() {
local device=$1

	clu-$(get_device_type $device) grow_by $device $(calculate_meta $device)

}

# Create DRBD disk
function create_node() {
local primary=$1
local secondary=$2
local resource=$3
local disk=$4
local device=${5:-$(get_next_device)}
local port=${6:-$(get_next_port)}

        # Add DRBD ressource config snipplet
	[ "$SKIP_CONF" == "1" ] || drbd_resource_config $primary $secondary $resource $disk $device $port >>/etc/drbd.conf

	# Activate drbd
	drbdadm create-md $resource
	drbdadm up $resource
}

# Create primary DRBD disk
function create_primary() {
local primary=$1
local secondary=$2
local resource=$3
local disk=$4
local device=${5:-$(get_next_device)}
local port=${6:-$(get_next_port)}

	# Create DRBD disk
	create_node $@

	# First time initialization
	drbdadm -- --overwrite-data-of-peer primary $resource
}

# Create secondary DRBD disk
function create_secondary() {
local primary=$1
local secondary=$2
local resource=$3
local disk=$4
local device=${5:-$(get_next_device)}
local port=${6:-$(get_next_port)}

	# Create DRBD disk
	create_node $@

	# First time initialization
	drbdadm secondary $resource
}

# Create disk primary and secondary
function create() {
local primary=$(hostname --fqdn)
local secondary=$1
local resource=$2
local device=${3:-$(get_next_device)}
local port=${4:-$(get_next_port)}
local size=${5:-1G}
# This is an ubuntu default when using the partitioner recipe
local lvm_vg=${7:-$(hostname --short)}

	# Primary
	# =====
        # Create logical volume
        lvcreate --size $size --name $resource $lvm_vg

	# Create local primary DRBD node
	create_primary $primary $secondary $resource /dev/$lvm_vg/$resource $device $port
	
	# Secondary
	# =========
	# Clone LV to secondary node
	clu-lvm clone /dev/$lvm_vg/$resource $secondary $lvm_vg

	# Create secondary DRBD node
	ssh $secondary clu-disk create_secondary $primary $secondary $resource /dev/$lvm_vg/$resource $device $port
}

# Create drbd disk from physical disk
function create_from_physical() {
local primary=$(hostname --fqdn)
local secondary=$1
local resource=$2
local device=${3:-$(get_next_device)}
local port=${4:-$(get_next_port)}
# This is an ubuntu default when using the partitioner recipe
local lvm_vg=${6:-$(hostname --short)}

	local disk=/dev/$lvm_vg/$resource
	
	# Make space for internal DRBD meta-data
	[ "$SKIP_RESIZE" == "1" ] || lvextend --size +$(calculate_meta $disk)M $disk
	
	# Create local primary DRBD node
	create_primary $primary $secondary $resource $disk $device $port
	
	# Secondary
	# =========
	# Clone LV to secondary node
	clu-lvm clone /dev/$lvm_vg/$resource $secondary $lvm_vg

	# Create secondary DRBD node
	ssh $secondary clu-disk create_secondary $primary $secondary $resource $disk $device $port
}

        
function destroy() {
local resource=$1

	drbdadm down $resource

	lvremove $(extract_disk $resource)

	[ "$SKIP_CONF" == "1" ] || cut_section $resource
}

# Main
# ====
ACTION=${1:list}
shift

$ACTION $@
